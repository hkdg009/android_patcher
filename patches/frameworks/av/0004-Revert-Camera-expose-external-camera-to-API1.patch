From 6a5290736efe7b8765e9f44747ebf6744778d507 Mon Sep 17 00:00:00 2001
From: Artem Borisov <dedsa2002@gmail.com>
Date: Sun, 12 Aug 2018 23:15:22 +0300
Subject: [PATCH 4/7] Revert "Camera: expose external camera to API1"

This reverts commit c3e9d6f704f7bf9e94c8447aa2f0f21e750c08be.
---
 .../camera/libcameraservice/CameraFlashlight.cpp   |  32 +--
 .../camera/libcameraservice/CameraFlashlight.h     |   9 +-
 services/camera/libcameraservice/CameraService.cpp | 231 ++++++++++++---------
 services/camera/libcameraservice/CameraService.h   |  30 +--
 .../camera/libcameraservice/api1/Camera2Client.cpp |   7 +-
 .../camera/libcameraservice/api1/Camera2Client.h   |   3 +-
 .../camera/libcameraservice/api1/CameraClient.cpp  |   2 +-
 .../libcameraservice/api1/client2/Parameters.cpp   |  56 ++---
 .../libcameraservice/api1/client2/Parameters.h     |   7 -
 .../libcameraservice/api2/CameraDeviceClient.cpp   |   6 +-
 .../libcameraservice/api2/CameraDeviceClient.h     |   1 -
 .../libcameraservice/common/Camera2ClientBase.cpp  |   7 +-
 .../libcameraservice/common/Camera2ClientBase.h    |   3 -
 .../common/CameraProviderManager.cpp               |  63 ++----
 .../common/CameraProviderManager.h                 |  18 +-
 15 files changed, 221 insertions(+), 254 deletions(-)

diff --git a/services/camera/libcameraservice/CameraFlashlight.cpp b/services/camera/libcameraservice/CameraFlashlight.cpp
index 394701a..e06a81f 100644
--- a/services/camera/libcameraservice/CameraFlashlight.cpp
+++ b/services/camera/libcameraservice/CameraFlashlight.cpp
@@ -32,15 +32,13 @@
 
 namespace android {
 
-using hardware::camera::common::V1_0::TorchModeStatus;
-
 /////////////////////////////////////////////////////////////////////
 // CameraFlashlight implementation begins
 // used by camera service to control flashflight.
 /////////////////////////////////////////////////////////////////////
 
 CameraFlashlight::CameraFlashlight(sp<CameraProviderManager> providerManager,
-        CameraProviderManager::StatusListener* callbacks) :
+        camera_module_callbacks_t* callbacks) :
         mProviderManager(providerManager),
         mCallbacks(callbacks),
         mFlashlightMapInitialized(false) {
@@ -61,7 +59,7 @@ status_t CameraFlashlight::createFlashlightControl(const String8& cameraId) {
     } else {
         // Only HAL1 devices do not support setTorchMode
         mFlashControl =
-                new CameraHardwareInterfaceFlashControl(mProviderManager, mCallbacks);
+                new CameraHardwareInterfaceFlashControl(mProviderManager, *mCallbacks);
     }
 
     return OK;
@@ -121,8 +119,7 @@ status_t CameraFlashlight::setTorchMode(const String8& cameraId, bool enabled) {
 }
 
 int CameraFlashlight::getNumberOfCameras() {
-    size_t len = mProviderManager->getAPI1CompatibleCameraDeviceIds().size();
-    return static_cast<int>(len);
+    return mProviderManager->getAPI1CompatibleCameraCount();
 }
 
 status_t CameraFlashlight::findFlashUnits() {
@@ -224,8 +221,9 @@ status_t CameraFlashlight::prepareDeviceOpen(const String8& cameraId) {
             int numCameras = getNumberOfCameras();
             for (int i = 0; i < numCameras; i++) {
                 if (hasFlashUnitLocked(String8::format("%d", i))) {
-                    mCallbacks->onTorchStatusChanged(
-                            String8::format("%d", i), TorchModeStatus::NOT_AVAILABLE);
+                    mCallbacks->torch_mode_status_change(mCallbacks,
+                            String8::format("%d", i).string(),
+                            TORCH_MODE_STATUS_NOT_AVAILABLE);
                 }
             }
         }
@@ -268,8 +266,9 @@ status_t CameraFlashlight::deviceClosed(const String8& cameraId) {
         int numCameras = getNumberOfCameras();
         for (int i = 0; i < numCameras; i++) {
             if (hasFlashUnitLocked(String8::format("%d", i))) {
-                mCallbacks->onTorchStatusChanged(
-                        String8::format("%d", i), TorchModeStatus::AVAILABLE_OFF);
+                mCallbacks->torch_mode_status_change(mCallbacks,
+                        String8::format("%d", i).string(),
+                        TORCH_MODE_STATUS_AVAILABLE_OFF);
             }
         }
     }
@@ -316,9 +315,9 @@ status_t ProviderFlashControl::setTorchMode(const String8& cameraId, bool enable
 
 CameraHardwareInterfaceFlashControl::CameraHardwareInterfaceFlashControl(
         sp<CameraProviderManager> manager,
-        CameraProviderManager::StatusListener* callbacks) :
+        const camera_module_callbacks_t& callbacks) :
         mProviderManager(manager),
-        mCallbacks(callbacks),
+        mCallbacks(&callbacks),
         mTorchEnabled(false) {
 }
 
@@ -334,7 +333,8 @@ CameraHardwareInterfaceFlashControl::~CameraHardwareInterfaceFlashControl() {
         if (mCallbacks) {
             ALOGV("%s: notify the framework that torch was turned off",
                     __FUNCTION__);
-            mCallbacks->onTorchStatusChanged(mCameraId, TorchModeStatus::AVAILABLE_OFF);
+            mCallbacks->torch_mode_status_change(mCallbacks,
+                    mCameraId.string(), TORCH_MODE_STATUS_AVAILABLE_OFF);
         }
     }
 }
@@ -368,7 +368,8 @@ status_t CameraHardwareInterfaceFlashControl::setTorchMode(
         // disabling the torch mode of currently opened device
         disconnectCameraDevice();
         mTorchEnabled = false;
-        mCallbacks->onTorchStatusChanged(cameraId, TorchModeStatus::AVAILABLE_OFF);
+        mCallbacks->torch_mode_status_change(mCallbacks,
+            cameraId.string(), TORCH_MODE_STATUS_AVAILABLE_OFF);
         return OK;
     }
 
@@ -378,7 +379,8 @@ status_t CameraHardwareInterfaceFlashControl::setTorchMode(
     }
 
     mTorchEnabled = true;
-    mCallbacks->onTorchStatusChanged(cameraId, TorchModeStatus::AVAILABLE_ON);
+    mCallbacks->torch_mode_status_change(mCallbacks,
+            cameraId.string(), TORCH_MODE_STATUS_AVAILABLE_ON);
     return OK;
 }
 
diff --git a/services/camera/libcameraservice/CameraFlashlight.h b/services/camera/libcameraservice/CameraFlashlight.h
index 07ce829..c86ee85 100644
--- a/services/camera/libcameraservice/CameraFlashlight.h
+++ b/services/camera/libcameraservice/CameraFlashlight.h
@@ -19,6 +19,7 @@
 
 #include <gui/GLConsumer.h>
 #include <gui/Surface.h>
+#include <hardware/camera_common.h>
 #include <utils/KeyedVector.h>
 #include <utils/SortedVector.h>
 #include "common/CameraProviderManager.h"
@@ -54,7 +55,7 @@ class FlashControlBase : public virtual VirtualLightRefBase {
 class CameraFlashlight : public virtual VirtualLightRefBase {
     public:
         CameraFlashlight(sp<CameraProviderManager> providerManager,
-                CameraProviderManager::StatusListener* callbacks);
+                camera_module_callbacks_t* callbacks);
         virtual ~CameraFlashlight();
 
         // Find all flash units. This must be called before other methods. All
@@ -98,7 +99,7 @@ class CameraFlashlight : public virtual VirtualLightRefBase {
 
         sp<CameraProviderManager> mProviderManager;
 
-        CameraProviderManager::StatusListener* mCallbacks;
+        const camera_module_callbacks_t *mCallbacks;
         SortedVector<String8> mOpenedCameraIds;
 
         // camera id -> if it has a flash unit
@@ -133,7 +134,7 @@ class CameraHardwareInterfaceFlashControl : public FlashControlBase {
     public:
         CameraHardwareInterfaceFlashControl(
                 sp<CameraProviderManager> manager,
-                CameraProviderManager::StatusListener* callbacks);
+                const camera_module_callbacks_t& callbacks);
         virtual ~CameraHardwareInterfaceFlashControl();
 
         // FlashControlBase
@@ -165,7 +166,7 @@ class CameraHardwareInterfaceFlashControl : public FlashControlBase {
         status_t hasFlashUnitLocked(const String8& cameraId, bool *hasFlash, bool keepDeviceOpen);
 
         sp<CameraProviderManager> mProviderManager;
-        CameraProviderManager::StatusListener* mCallbacks;
+        const camera_module_callbacks_t *mCallbacks;
         sp<CameraHardwareInterface> mDevice;
         String8 mCameraId;
         CameraParameters mParameters;
diff --git a/services/camera/libcameraservice/CameraService.cpp b/services/camera/libcameraservice/CameraService.cpp
index c41de82..b85b09b 100644
--- a/services/camera/libcameraservice/CameraService.cpp
+++ b/services/camera/libcameraservice/CameraService.cpp
@@ -109,13 +109,79 @@ static void setLogLevel(int level) {
 
 // ----------------------------------------------------------------------------
 
+extern "C" {
+static void camera_device_status_change(
+        const struct camera_module_callbacks* callbacks,
+        int camera_id,
+        int new_status) {
+    sp<CameraService> cs = const_cast<CameraService*>(
+            static_cast<const CameraService*>(callbacks));
+    String8 id = String8::format("%d", camera_id);
+
+    CameraDeviceStatus newStatus{CameraDeviceStatus::NOT_PRESENT};
+    switch (new_status) {
+        case CAMERA_DEVICE_STATUS_NOT_PRESENT:
+            newStatus = CameraDeviceStatus::NOT_PRESENT;
+            break;
+        case CAMERA_DEVICE_STATUS_PRESENT:
+            newStatus = CameraDeviceStatus::PRESENT;
+            break;
+        case CAMERA_DEVICE_STATUS_ENUMERATING:
+            newStatus = CameraDeviceStatus::ENUMERATING;
+            break;
+        default:
+            ALOGW("Unknown device status change to %d", new_status);
+            break;
+    }
+    cs->onDeviceStatusChanged(id, newStatus);
+}
+
+static void torch_mode_status_change(
+        const struct camera_module_callbacks* callbacks,
+        const char* camera_id,
+        int new_status) {
+    if (!callbacks || !camera_id) {
+        ALOGE("%s invalid parameters. callbacks %p, camera_id %p", __FUNCTION__,
+                callbacks, camera_id);
+    }
+    sp<CameraService> cs = const_cast<CameraService*>(
+                                static_cast<const CameraService*>(callbacks));
+
+    TorchModeStatus status;
+    switch (new_status) {
+        case TORCH_MODE_STATUS_NOT_AVAILABLE:
+            status = TorchModeStatus::NOT_AVAILABLE;
+            break;
+        case TORCH_MODE_STATUS_AVAILABLE_OFF:
+            status = TorchModeStatus::AVAILABLE_OFF;
+            break;
+        case TORCH_MODE_STATUS_AVAILABLE_ON:
+            status = TorchModeStatus::AVAILABLE_ON;
+            break;
+        default:
+            ALOGE("Unknown torch status %d", new_status);
+            return;
+    }
+
+    cs->onTorchStatusChanged(
+        String8(camera_id),
+        status);
+}
+} // extern "C"
+
+// ----------------------------------------------------------------------------
+
 static const String16 sManageCameraPermission("android.permission.MANAGE_CAMERA");
 
 CameraService::CameraService() :
         mEventLog(DEFAULT_EVENT_LOG_LENGTH),
-        mNumberOfCameras(0),
+        mNumberOfCameras(0), mNumberOfNormalCameras(0),
         mSoundRef(0), mInitialized(false) {
     ALOGI("CameraService started (pid=%d)", getpid());
+
+    this->camera_device_status_change = android::camera_device_status_change;
+    this->torch_mode_status_change = android::torch_mode_status_change;
+
     mServiceLockWrapper = std::make_shared<WaitableMutexWrapper>(&mServiceLock);
 }
 
@@ -145,42 +211,52 @@ void CameraService::onFirstRef()
 
 status_t CameraService::enumerateProviders() {
     status_t res;
+    Mutex::Autolock l(mServiceLock);
 
-    std::vector<std::string> deviceIds;
-    {
-        Mutex::Autolock l(mServiceLock);
-
-        if (nullptr == mCameraProviderManager.get()) {
-            mCameraProviderManager = new CameraProviderManager();
-            res = mCameraProviderManager->initialize(this);
-            if (res != OK) {
-                ALOGE("%s: Unable to initialize camera provider manager: %s (%d)",
-                        __FUNCTION__, strerror(-res), res);
-                return res;
-            }
+    if (nullptr == mCameraProviderManager.get()) {
+        mCameraProviderManager = new CameraProviderManager();
+        res = mCameraProviderManager->initialize(this);
+        if (res != OK) {
+            ALOGE("%s: Unable to initialize camera provider manager: %s (%d)",
+                    __FUNCTION__, strerror(-res), res);
+            return res;
         }
+    }
 
+    mNumberOfCameras = mCameraProviderManager->getCameraCount();
+    mNumberOfNormalCameras =
+            mCameraProviderManager->getAPI1CompatibleCameraCount();
 
-        // Setup vendor tags before we call get_camera_info the first time
-        // because HAL might need to setup static vendor keys in get_camera_info
-        // TODO: maybe put this into CameraProviderManager::initialize()?
-        mCameraProviderManager->setUpVendorTags();
-
-        if (nullptr == mFlashlight.get()) {
-            mFlashlight = new CameraFlashlight(mCameraProviderManager, this);
-        }
-
-        res = mFlashlight->findFlashUnits();
-        if (res != OK) {
-            ALOGE("Failed to enumerate flash units: %s (%d)", strerror(-res), res);
-        }
+    // Setup vendor tags before we call get_camera_info the first time
+    // because HAL might need to setup static vendor keys in get_camera_info
+    // TODO: maybe put this into CameraProviderManager::initialize()?
+    mCameraProviderManager->setUpVendorTags();
 
-        deviceIds = mCameraProviderManager->getCameraDeviceIds();
+    if (nullptr == mFlashlight.get()) {
+        mFlashlight = new CameraFlashlight(mCameraProviderManager, this);
     }
 
+    res = mFlashlight->findFlashUnits();
+    if (res != OK) {
+        ALOGE("Failed to enumerate flash units: %s (%d)", strerror(-res), res);
+    }
 
-    for (auto& cameraId : deviceIds) {
+    for (auto& cameraId : mCameraProviderManager->getCameraDeviceIds()) {
         String8 id8 = String8(cameraId.c_str());
+        bool cameraFound = false;
+        {
+
+            Mutex::Autolock lock(mCameraStatesLock);
+            auto iter = mCameraStates.find(id8);
+            if (iter != mCameraStates.end()) {
+                cameraFound = true;
+            }
+        }
+
+        if (!cameraFound) {
+            addStates(id8);
+        }
+
         onDeviceStatusChanged(id8, CameraDeviceStatus::PRESENT);
     }
 
@@ -217,13 +293,6 @@ void CameraService::onNewProviderRegistered() {
     enumerateProviders();
 }
 
-void CameraService::updateCameraNumAndIds() {
-    Mutex::Autolock l(mServiceLock);
-    mNumberOfCameras = mCameraProviderManager->getCameraCount();
-    mNormalDeviceIds =
-            mCameraProviderManager->getAPI1CompatibleCameraDeviceIds();
-}
-
 void CameraService::addStates(const String8 id) {
     std::string cameraId(id.c_str());
     hardware::camera::common::V1_0::CameraResourceCost cost;
@@ -247,13 +316,10 @@ void CameraService::addStates(const String8 id) {
         Mutex::Autolock al(mTorchStatusMutex);
         mTorchStatusMap.add(id, TorchModeStatus::AVAILABLE_OFF);
     }
-
-    updateCameraNumAndIds();
     logDeviceAdded(id, "Device added");
 }
 
 void CameraService::removeStates(const String8 id) {
-    updateCameraNumAndIds();
     if (mFlashlight->hasFlashUnit(id)) {
         Mutex::Autolock al(mTorchStatusMutex);
         mTorchStatusMap.removeItem(id);
@@ -299,16 +365,15 @@ void CameraService::onDeviceStatusChanged(const String8& id,
     if (newStatus == StatusInternal::NOT_PRESENT) {
         logDeviceRemoved(id, String8::format("Device status changed from %d to %d", oldStatus,
                 newStatus));
-
-        // Set the device status to NOT_PRESENT, clients will no longer be able to connect
-        // to this device until the status changes
-        updateStatus(StatusInternal::NOT_PRESENT, id);
-
         sp<BasicClient> clientToDisconnect;
         {
             // Don't do this in updateStatus to avoid deadlock over mServiceLock
             Mutex::Autolock lock(mServiceLock);
 
+            // Set the device status to NOT_PRESENT, clients will no longer be able to connect
+            // to this device until the status changes
+            updateStatus(StatusInternal::NOT_PRESENT, id);
+
             // Remove cached shim parameters
             state->setShimParams(CameraParameters());
 
@@ -411,7 +476,7 @@ Status CameraService::getNumberOfCameras(int32_t type, int32_t* numCameras) {
     Mutex::Autolock l(mServiceLock);
     switch (type) {
         case CAMERA_TYPE_BACKWARD_COMPATIBLE:
-            *numCameras = static_cast<int>(mNormalDeviceIds.size());
+            *numCameras = mNumberOfNormalCameras;
             break;
         case CAMERA_TYPE_ALL:
             *numCameras = mNumberOfCameras;
@@ -441,8 +506,7 @@ Status CameraService::getCameraInfo(int cameraId,
     }
 
     Status ret = Status::ok();
-    status_t err = mCameraProviderManager->getCameraInfo(
-            cameraIdIntToStrLocked(cameraId), cameraInfo);
+    status_t err = mCameraProviderManager->getCameraInfo(std::to_string(cameraId), cameraInfo);
     if (err != OK) {
         ret = STATUS_ERROR_FMT(ERROR_INVALID_OPERATION,
                 "Error retrieving camera info from device %d: %s (%d)", cameraId,
@@ -452,19 +516,13 @@ Status CameraService::getCameraInfo(int cameraId,
     return ret;
 }
 
-std::string CameraService::cameraIdIntToStrLocked(int cameraIdInt) {
-    if (cameraIdInt < 0 || cameraIdInt >= static_cast<int>(mNormalDeviceIds.size())) {
-        ALOGE("%s: input id %d invalid: valid range  (0, %zu)",
-                __FUNCTION__, cameraIdInt, mNormalDeviceIds.size());
-        return std::string{};
+int CameraService::cameraIdToInt(const String8& cameraId) {
+    int id;
+    bool success = base::ParseInt(cameraId.string(), &id, 0);
+    if (!success) {
+        return -1;
     }
-
-    return mNormalDeviceIds[cameraIdInt];
-}
-
-String8 CameraService::cameraIdIntToStr(int cameraIdInt) {
-    Mutex::Autolock lock(mServiceLock);
-    return String8(cameraIdIntToStrLocked(cameraIdInt).c_str());
+    return id;
 }
 
 Status CameraService::getCameraCharacteristics(const String16& cameraId,
@@ -581,8 +639,8 @@ Status CameraService::filterGetInfoErrorCode(status_t err) {
 
 Status CameraService::makeClient(const sp<CameraService>& cameraService,
         const sp<IInterface>& cameraCb, const String16& packageName, const String8& cameraId,
-        int api1CameraId, int facing, int clientPid, uid_t clientUid, int servicePid,
-        bool legacyMode, int halVersion, int deviceVersion, apiLevel effectiveApiLevel,
+        int facing, int clientPid, uid_t clientUid, int servicePid, bool legacyMode,
+        int halVersion, int deviceVersion, apiLevel effectiveApiLevel,
         /*out*/sp<BasicClient>* client) {
 
     if (halVersion < 0 || halVersion == deviceVersion) {
@@ -592,9 +650,8 @@ Status CameraService::makeClient(const sp<CameraService>& cameraService,
           case CAMERA_DEVICE_API_VERSION_1_0:
             if (effectiveApiLevel == API_1) {  // Camera1 API route
                 sp<ICameraClient> tmp = static_cast<ICameraClient*>(cameraCb.get());
-                *client = new CameraClient(cameraService, tmp, packageName,
-                        api1CameraId, facing, clientPid, clientUid,
-                        getpid(), legacyMode);
+                *client = new CameraClient(cameraService, tmp, packageName, cameraIdToInt(cameraId),
+                        facing, clientPid, clientUid, getpid(), legacyMode);
             } else { // Camera2 API route
                 ALOGW("Camera using old HAL version: %d", deviceVersion);
                 return STATUS_ERROR_FMT(ERROR_DEPRECATED_HAL,
@@ -609,10 +666,8 @@ Status CameraService::makeClient(const sp<CameraService>& cameraService,
           case CAMERA_DEVICE_API_VERSION_3_4:
             if (effectiveApiLevel == API_1) { // Camera1 API route
                 sp<ICameraClient> tmp = static_cast<ICameraClient*>(cameraCb.get());
-                *client = new Camera2Client(cameraService, tmp, packageName,
-                        cameraId, api1CameraId,
-                        facing, clientPid, clientUid,
-                        servicePid, legacyMode);
+                *client = new Camera2Client(cameraService, tmp, packageName, cameraIdToInt(cameraId),
+                        facing, clientPid, clientUid, servicePid, legacyMode);
             } else { // Camera2 API route
                 sp<hardware::camera2::ICameraDeviceCallbacks> tmp =
                         static_cast<hardware::camera2::ICameraDeviceCallbacks*>(cameraCb.get());
@@ -634,9 +689,8 @@ Status CameraService::makeClient(const sp<CameraService>& cameraService,
             halVersion == CAMERA_DEVICE_API_VERSION_1_0) {
             // Only support higher HAL version device opened as HAL1.0 device.
             sp<ICameraClient> tmp = static_cast<ICameraClient*>(cameraCb.get());
-            *client = new CameraClient(cameraService, tmp, packageName,
-                    api1CameraId, facing, clientPid, clientUid,
-                    servicePid, legacyMode);
+            *client = new CameraClient(cameraService, tmp, packageName, cameraIdToInt(cameraId),
+                    facing, clientPid, clientUid, servicePid, legacyMode);
         } else {
             // Other combinations (e.g. HAL3.x open as HAL2.x) are not supported yet.
             ALOGE("Invalid camera HAL version %x: HAL %x device can only be"
@@ -732,8 +786,7 @@ Status CameraService::initializeShimMetadata(int cameraId) {
     Status ret = Status::ok();
     sp<Client> tmp = nullptr;
     if (!(ret = connectHelper<ICameraClient,Client>(
-            sp<ICameraClient>{nullptr}, id, cameraId,
-            static_cast<int>(CAMERA_HAL_API_VERSION_UNSPECIFIED),
+            sp<ICameraClient>{nullptr}, id, static_cast<int>(CAMERA_HAL_API_VERSION_UNSPECIFIED),
             internalPackageName, uid, USE_CALLING_PID,
             API_1, /*legacyMode*/ false, /*shimUpdateOnly*/ true,
             /*out*/ tmp)
@@ -1186,7 +1239,7 @@ status_t CameraService::handleEvictionsLocked(const String8& cameraId, int clien
 
 Status CameraService::connect(
         const sp<ICameraClient>& cameraClient,
-        int api1CameraId,
+        int cameraId,
         const String16& clientPackageName,
         int clientUid,
         int clientPid,
@@ -1195,10 +1248,9 @@ Status CameraService::connect(
 
     ATRACE_CALL();
     Status ret = Status::ok();
-
-    String8 id = cameraIdIntToStr(api1CameraId);
+    String8 id = String8::format("%d", cameraId);
     sp<Client> client = nullptr;
-    ret = connectHelper<ICameraClient,Client>(cameraClient, id, api1CameraId,
+    ret = connectHelper<ICameraClient,Client>(cameraClient, id,
             CAMERA_HAL_API_VERSION_UNSPECIFIED, clientPackageName, clientUid, clientPid, API_1,
             /*legacyMode*/ false, /*shimUpdateOnly*/ false,
             /*out*/client);
@@ -1215,18 +1267,18 @@ Status CameraService::connect(
 
 Status CameraService::connectLegacy(
         const sp<ICameraClient>& cameraClient,
-        int api1CameraId, int halVersion,
+        int cameraId, int halVersion,
         const String16& clientPackageName,
         int clientUid,
         /*out*/
         sp<ICamera>* device) {
 
     ATRACE_CALL();
-    String8 id = cameraIdIntToStr(api1CameraId);
+    String8 id = String8::format("%d", cameraId);
 
     Status ret = Status::ok();
     sp<Client> client = nullptr;
-    ret = connectHelper<ICameraClient,Client>(cameraClient, id, api1CameraId, halVersion,
+    ret = connectHelper<ICameraClient,Client>(cameraClient, id, halVersion,
             clientPackageName, clientUid, USE_CALLING_PID, API_1,
             /*legacyMode*/ true, /*shimUpdateOnly*/ false,
             /*out*/client);
@@ -1254,7 +1306,6 @@ Status CameraService::connectDevice(
     String8 id = String8(cameraId);
     sp<CameraDeviceClient> client = nullptr;
     ret = connectHelper<hardware::camera2::ICameraDeviceCallbacks,CameraDeviceClient>(cameraCb, id,
-            /*api1CameraId*/-1,
             CAMERA_HAL_API_VERSION_UNSPECIFIED, clientPackageName,
             clientUid, USE_CALLING_PID, API_2,
             /*legacyMode*/ false, /*shimUpdateOnly*/ false,
@@ -1272,8 +1323,8 @@ Status CameraService::connectDevice(
 
 template<class CALLBACK, class CLIENT>
 Status CameraService::connectHelper(const sp<CALLBACK>& cameraCb, const String8& cameraId,
-        int api1CameraId, int halVersion, const String16& clientPackageName, int clientUid,
-        int clientPid, apiLevel effectiveApiLevel, bool legacyMode, bool shimUpdateOnly,
+        int halVersion, const String16& clientPackageName, int clientUid, int clientPid,
+        apiLevel effectiveApiLevel, bool legacyMode, bool shimUpdateOnly,
         /*out*/sp<CLIENT>& device) {
     binder::Status ret = binder::Status::ok();
 
@@ -1356,10 +1407,8 @@ Status CameraService::connectHelper(const sp<CALLBACK>& cameraCb, const String8&
         }
 
         sp<BasicClient> tmp = nullptr;
-        if(!(ret = makeClient(this, cameraCb, clientPackageName,
-                cameraId, api1CameraId, facing,
-                clientPid, clientUid, getpid(), legacyMode,
-                halVersion, deviceVersion, effectiveApiLevel,
+        if(!(ret = makeClient(this, cameraCb, clientPackageName, cameraId, facing, clientPid,
+                clientUid, getpid(), legacyMode, halVersion, deviceVersion, effectiveApiLevel,
                 /*out*/&tmp)).isOk()) {
             return ret;
         }
@@ -2070,8 +2119,7 @@ void CameraService::playSound(sound_kind kind) {
 CameraService::Client::Client(const sp<CameraService>& cameraService,
         const sp<ICameraClient>& cameraClient,
         const String16& clientPackageName,
-        const String8& cameraIdStr,
-        int api1CameraId, int cameraFacing,
+        const String8& cameraIdStr, int cameraFacing,
         int clientPid, uid_t clientUid,
         int servicePid) :
         CameraService::BasicClient(cameraService,
@@ -2080,7 +2128,7 @@ CameraService::Client::Client(const sp<CameraService>& cameraService,
                 cameraIdStr, cameraFacing,
                 clientPid, clientUid,
                 servicePid),
-        mCameraId(api1CameraId)
+        mCameraId(CameraService::cameraIdToInt(cameraIdStr))
 {
     int callingPid = getCallingPid();
     LOG1("Client::Client E (pid %d, id %d)", callingPid, mCameraId);
@@ -2704,10 +2752,7 @@ status_t CameraService::dump(int fd, const Vector<String16>& args) {
     }
     dprintf(fd, "\n== Service global info: ==\n\n");
     dprintf(fd, "Number of camera devices: %d\n", mNumberOfCameras);
-    dprintf(fd, "Number of normal camera devices: %zu\n", mNormalDeviceIds.size());
-    for (size_t i = 0; i < mNormalDeviceIds.size(); i++) {
-        dprintf(fd, "    Device %zu maps to \"%s\"\n", i, mNormalDeviceIds[i].c_str());
-    }
+    dprintf(fd, "Number of normal camera devices: %d\n", mNumberOfNormalCameras);
     String8 activeClientString = mActiveClientManager.toString();
     dprintf(fd, "Active Camera Clients:\n%s", activeClientString.string());
     dprintf(fd, "Allowed user IDs: %s\n", toString(mAllowedUsers).string());
diff --git a/services/camera/libcameraservice/CameraService.h b/services/camera/libcameraservice/CameraService.h
index 8d4bcdb..320ce33 100644
--- a/services/camera/libcameraservice/CameraService.h
+++ b/services/camera/libcameraservice/CameraService.h
@@ -62,6 +62,7 @@ class CameraService :
     public BinderService<CameraService>,
     public virtual ::android::hardware::BnCameraService,
     public virtual IBinder::DeathRecipient,
+    public camera_module_callbacks_t,
     public virtual CameraProviderManager::StatusListener
 {
     friend class BinderService<CameraService>;
@@ -334,7 +335,6 @@ public:
                 const sp<hardware::ICameraClient>& cameraClient,
                 const String16& clientPackageName,
                 const String8& cameraIdStr,
-                int api1CameraId,
                 int cameraFacing,
                 int clientPid,
                 uid_t clientUid,
@@ -556,8 +556,7 @@ private:
     // Eumerate all camera providers in the system
     status_t enumerateProviders();
 
-    // Add/remove a new camera to camera and torch state lists or remove an unplugged one
-    // Caller must not hold mServiceLock
+    // Add a new camera to camera and torch state lists or remove an unplugged one
     void addStates(const String8 id);
     void removeStates(const String8 id);
 
@@ -584,7 +583,7 @@ private:
     // Single implementation shared between the various connect calls
     template<class CALLBACK, class CLIENT>
     binder::Status connectHelper(const sp<CALLBACK>& cameraCb, const String8& cameraId,
-            int api1CameraId, int halVersion, const String16& clientPackageName,
+            int halVersion, const String16& clientPackageName,
             int clientUid, int clientPid,
             apiLevel effectiveApiLevel, bool legacyMode, bool shimUpdateOnly,
             /*out*/sp<CLIENT>& device);
@@ -649,16 +648,9 @@ private:
     void finishConnectLocked(const sp<BasicClient>& client, const DescriptorPtr& desc);
 
     /**
-     * Returns the underlying camera Id string mapped to a camera id int
-     * Empty string is returned when the cameraIdInt is invalid.
+     * Returns the integer corresponding to the given camera ID string, or -1 on failure.
      */
-    String8 cameraIdIntToStr(int cameraIdInt);
-
-    /**
-     * Returns the underlying camera Id string mapped to a camera id int
-     * Empty string is returned when the cameraIdInt is invalid.
-     */
-    std::string cameraIdIntToStrLocked(int cameraIdInt);
+    static int cameraIdToInt(const String8& cameraId);
 
     /**
      * Remove a single client corresponding to the given camera id from the list of active clients.
@@ -726,14 +718,8 @@ private:
      */
     void dumpEventLog(int fd);
 
-    /**
-     * This method will acquire mServiceLock
-     */
-    void updateCameraNumAndIds();
-
     int                 mNumberOfCameras;
-
-    std::vector<std::string> mNormalDeviceIds;
+    int                 mNumberOfNormalCameras;
 
     // sounds
     sp<MediaPlayer>     newMediaPlayer(const char *file);
@@ -843,8 +829,8 @@ private:
 
     static binder::Status makeClient(const sp<CameraService>& cameraService,
             const sp<IInterface>& cameraCb, const String16& packageName, const String8& cameraId,
-            int api1CameraId, int facing, int clientPid, uid_t clientUid, int servicePid,
-            bool legacyMode, int halVersion, int deviceVersion, apiLevel effectiveApiLevel,
+            int facing, int clientPid, uid_t clientUid, int servicePid, bool legacyMode,
+            int halVersion, int deviceVersion, apiLevel effectiveApiLevel,
             /*out*/sp<BasicClient>* client);
 
     status_t checkCameraAccess(const String16& opPackageName);
diff --git a/services/camera/libcameraservice/api1/Camera2Client.cpp b/services/camera/libcameraservice/api1/Camera2Client.cpp
index 65faac9..dd1cf2c 100644
--- a/services/camera/libcameraservice/api1/Camera2Client.cpp
+++ b/services/camera/libcameraservice/api1/Camera2Client.cpp
@@ -49,17 +49,16 @@ static int getCallingPid() {
 Camera2Client::Camera2Client(const sp<CameraService>& cameraService,
         const sp<hardware::ICameraClient>& cameraClient,
         const String16& clientPackageName,
-        const String8& cameraDeviceId,
-        int api1CameraId,
+        int cameraId,
         int cameraFacing,
         int clientPid,
         uid_t clientUid,
         int servicePid,
         bool legacyMode):
         Camera2ClientBase(cameraService, cameraClient, clientPackageName,
-                cameraDeviceId, api1CameraId, cameraFacing,
+                String8::format("%d", cameraId), cameraFacing,
                 clientPid, clientUid, servicePid),
-        mParameters(api1CameraId, cameraFacing)
+        mParameters(cameraId, cameraFacing)
 {
     ATRACE_CALL();
 
diff --git a/services/camera/libcameraservice/api1/Camera2Client.h b/services/camera/libcameraservice/api1/Camera2Client.h
index 44929c3..c17cbd4 100644
--- a/services/camera/libcameraservice/api1/Camera2Client.h
+++ b/services/camera/libcameraservice/api1/Camera2Client.h
@@ -91,8 +91,7 @@ public:
     Camera2Client(const sp<CameraService>& cameraService,
             const sp<hardware::ICameraClient>& cameraClient,
             const String16& clientPackageName,
-            const String8& cameraDeviceId,
-            int api1CameraId,
+            int cameraId,
             int cameraFacing,
             int clientPid,
             uid_t clientUid,
diff --git a/services/camera/libcameraservice/api1/CameraClient.cpp b/services/camera/libcameraservice/api1/CameraClient.cpp
index f1203f9..4563b97 100644
--- a/services/camera/libcameraservice/api1/CameraClient.cpp
+++ b/services/camera/libcameraservice/api1/CameraClient.cpp
@@ -42,7 +42,7 @@ CameraClient::CameraClient(const sp<CameraService>& cameraService,
         int clientPid, int clientUid,
         int servicePid, bool legacyMode):
         Client(cameraService, cameraClient, clientPackageName,
-                String8::format("%d", cameraId), cameraId, cameraFacing, clientPid,
+                String8::format("%d", cameraId), cameraFacing, clientPid,
                 clientUid, servicePid)
 {
     int callingPid = getCallingPid();
diff --git a/services/camera/libcameraservice/api1/client2/Parameters.cpp b/services/camera/libcameraservice/api1/client2/Parameters.cpp
index d66dec4..7373b81 100644
--- a/services/camera/libcameraservice/api1/client2/Parameters.cpp
+++ b/services/camera/libcameraservice/api1/client2/Parameters.cpp
@@ -761,17 +761,12 @@ status_t Parameters::initialize(const CameraMetadata *info, int deviceVersion) {
     focusingAreas.clear();
     focusingAreas.add(Parameters::Area(0,0,0,0,0));
 
-    if (fastInfo.isExternalCamera) {
-        params.setFloat(CameraParameters::KEY_FOCAL_LENGTH, -1.0);
-    } else {
-        camera_metadata_ro_entry_t availableFocalLengths =
-            staticInfo(ANDROID_LENS_INFO_AVAILABLE_FOCAL_LENGTHS, 0, 0, false);
-        if (!availableFocalLengths.count) return NO_INIT;
-
-        float minFocalLength = availableFocalLengths.data.f[0];
-        params.setFloat(CameraParameters::KEY_FOCAL_LENGTH, minFocalLength);
-    }
+    camera_metadata_ro_entry_t availableFocalLengths =
+        staticInfo(ANDROID_LENS_INFO_AVAILABLE_FOCAL_LENGTHS, 0, 0, false);
+    if (!availableFocalLengths.count) return NO_INIT;
 
+    float minFocalLength = availableFocalLengths.data.f[0];
+    params.setFloat(CameraParameters::KEY_FOCAL_LENGTH, minFocalLength);
 
     float horizFov, vertFov;
     res = calculatePictureFovs(&horizFov, &vertFov);
@@ -1109,15 +1104,9 @@ status_t Parameters::buildFastInfo() {
             focusDistanceCalibration.data.u8[0] !=
             ANDROID_LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED);
 
-
-    camera_metadata_ro_entry_t hwLevel = staticInfo(ANDROID_INFO_SUPPORTED_HARDWARE_LEVEL);
-    if (!hwLevel.count) return NO_INIT;
-    fastInfo.isExternalCamera =
-            hwLevel.data.u8[0] == ANDROID_INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL;
-
     camera_metadata_ro_entry_t availableFocalLengths =
-        staticInfo(ANDROID_LENS_INFO_AVAILABLE_FOCAL_LENGTHS, 0, 0, /*required*/false);
-    if (!availableFocalLengths.count && !fastInfo.isExternalCamera) return NO_INIT;
+        staticInfo(ANDROID_LENS_INFO_AVAILABLE_FOCAL_LENGTHS);
+    if (!availableFocalLengths.count) return NO_INIT;
 
     SortedVector<int32_t> availableFormats = getAvailableOutputFormats();
     if (!availableFormats.size()) return NO_INIT;
@@ -1202,14 +1191,10 @@ status_t Parameters::buildFastInfo() {
 
     // Find smallest (widest-angle) focal length to use as basis of still
     // picture FOV reporting.
-    if (fastInfo.isExternalCamera) {
-        fastInfo.minFocalLength = -1.0;
-    } else {
-        fastInfo.minFocalLength = availableFocalLengths.data.f[0];
-        for (size_t i = 1; i < availableFocalLengths.count; i++) {
-            if (fastInfo.minFocalLength > availableFocalLengths.data.f[i]) {
-                fastInfo.minFocalLength = availableFocalLengths.data.f[i];
-            }
+    fastInfo.minFocalLength = availableFocalLengths.data.f[0];
+    for (size_t i = 1; i < availableFocalLengths.count; i++) {
+        if (fastInfo.minFocalLength > availableFocalLengths.data.f[i]) {
+            fastInfo.minFocalLength = availableFocalLengths.data.f[i];
         }
     }
 
@@ -2936,13 +2921,8 @@ status_t Parameters::getFilteredSizes(Size limit, Vector<Size> *sizes) {
         if (sc.isInput == ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS_OUTPUT &&
                 sc.format == HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED &&
                 sc.width <= limit.width && sc.height <= limit.height) {
-            int64_t minFrameDuration = getMinFrameDurationNs(
-                    {sc.width, sc.height}, HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED);
-            if (minFrameDuration > MAX_PREVIEW_RECORD_DURATION_NS) {
-                // Filter slow sizes from preview/record
-                continue;
-            }
-            sizes->push({sc.width, sc.height});
+            Size sz = {sc.width, sc.height};
+            sizes->push(sz);
         }
     }
 
@@ -3152,16 +3132,6 @@ Parameters::CropRegion Parameters::calculateCropRegion(bool previewOnly) const {
 
 status_t Parameters::calculatePictureFovs(float *horizFov, float *vertFov)
         const {
-    if (fastInfo.isExternalCamera) {
-        if (horizFov != NULL) {
-            *horizFov = -1.0;
-        }
-        if (vertFov != NULL) {
-            *vertFov = -1.0;
-        }
-        return OK;
-    }
-
     camera_metadata_ro_entry_t sensorSize =
             staticInfo(ANDROID_SENSOR_INFO_PHYSICAL_SIZE, 2, 2);
     if (!sensorSize.count) return NO_INIT;
diff --git a/services/camera/libcameraservice/api1/client2/Parameters.h b/services/camera/libcameraservice/api1/client2/Parameters.h
index 97f8ea7..f0bde5b 100644
--- a/services/camera/libcameraservice/api1/client2/Parameters.h
+++ b/services/camera/libcameraservice/api1/client2/Parameters.h
@@ -209,11 +209,6 @@ struct Parameters {
     static const int32_t FPS_MARGIN = 1;
     // Max FPS for default parameters
     static const int32_t MAX_DEFAULT_FPS = 30;
-    // Minimum FPS for a size to be listed in supported preview/video sizes
-    // Set to slightly less than 30.0 to have some tolerance margin
-    static constexpr double MIN_PREVIEW_RECORD_FPS = 29.97;
-    // Maximum frame duration for a size to be listed in supported preview/video sizes
-    static constexpr int64_t MAX_PREVIEW_RECORD_DURATION_NS = 1e9 / MIN_PREVIEW_RECORD_FPS;
 
     // Full static camera info, object owned by someone else, such as
     // Camera2Device.
@@ -240,7 +235,6 @@ struct Parameters {
             }
         };
         DefaultKeyedVector<uint8_t, OverrideModes> sceneModeOverrides;
-        bool isExternalCamera;
         float minFocalLength;
         bool useFlexibleYuv;
         Size maxJpegSize;
@@ -389,7 +383,6 @@ private:
     Vector<Size> availablePreviewSizes;
     Vector<Size> availableVideoSizes;
     // Get size list (that are no larger than limit) from static metadata.
-    // This method filtered size with minFrameDuration < MAX_PREVIEW_RECORD_DURATION_NS
     status_t getFilteredSizes(Size limit, Vector<Size> *sizes);
     // Get max size (from the size array) that matches the given aspect ratio.
     Size getMaxSizeForRatio(float ratio, const int32_t* sizeArray, size_t count);
diff --git a/services/camera/libcameraservice/api2/CameraDeviceClient.cpp b/services/camera/libcameraservice/api2/CameraDeviceClient.cpp
index c49de8e..2297ed3 100644
--- a/services/camera/libcameraservice/api2/CameraDeviceClient.cpp
+++ b/services/camera/libcameraservice/api2/CameraDeviceClient.cpp
@@ -49,7 +49,6 @@ CameraDeviceClientBase::CameraDeviceClientBase(
         const sp<hardware::camera2::ICameraDeviceCallbacks>& remoteCallback,
         const String16& clientPackageName,
         const String8& cameraId,
-        int api1CameraId,
         int cameraFacing,
         int clientPid,
         uid_t clientUid,
@@ -63,8 +62,6 @@ CameraDeviceClientBase::CameraDeviceClientBase(
             clientUid,
             servicePid),
     mRemoteCallback(remoteCallback) {
-    // We don't need it for API2 clients, but Camera2ClientBase requires it.
-    (void) api1CameraId;
 }
 
 // Interface used by CameraService
@@ -78,8 +75,7 @@ CameraDeviceClient::CameraDeviceClient(const sp<CameraService>& cameraService,
         uid_t clientUid,
         int servicePid) :
     Camera2ClientBase(cameraService, remoteCallback, clientPackageName,
-                cameraId, /*API1 camera ID*/ -1,
-                cameraFacing, clientPid, clientUid, servicePid),
+                cameraId, cameraFacing, clientPid, clientUid, servicePid),
     mInputStream(),
     mStreamingRequestId(REQUEST_ID_NONE),
     mRequestIdCounter(0) {
diff --git a/services/camera/libcameraservice/api2/CameraDeviceClient.h b/services/camera/libcameraservice/api2/CameraDeviceClient.h
index 5aaf5aa..5bec39c 100644
--- a/services/camera/libcameraservice/api2/CameraDeviceClient.h
+++ b/services/camera/libcameraservice/api2/CameraDeviceClient.h
@@ -45,7 +45,6 @@ protected:
             const sp<hardware::camera2::ICameraDeviceCallbacks>& remoteCallback,
             const String16& clientPackageName,
             const String8& cameraId,
-            int api1CameraId,
             int cameraFacing,
             int clientPid,
             uid_t clientUid,
diff --git a/services/camera/libcameraservice/common/Camera2ClientBase.cpp b/services/camera/libcameraservice/common/Camera2ClientBase.cpp
index ce006a7..3a3d5f6 100644
--- a/services/camera/libcameraservice/common/Camera2ClientBase.cpp
+++ b/services/camera/libcameraservice/common/Camera2ClientBase.cpp
@@ -48,16 +48,15 @@ Camera2ClientBase<TClientBase>::Camera2ClientBase(
         const sp<TCamCallbacks>& remoteCallback,
         const String16& clientPackageName,
         const String8& cameraId,
-        int api1CameraId,
         int cameraFacing,
         int clientPid,
         uid_t clientUid,
         int servicePid):
         TClientBase(cameraService, remoteCallback, clientPackageName,
-                cameraId, api1CameraId, cameraFacing, clientPid, clientUid, servicePid),
+                cameraId, cameraFacing, clientPid, clientUid, servicePid),
         mSharedCameraCallbacks(remoteCallback),
         mDeviceVersion(cameraService->getDeviceVersion(TClientBase::mCameraIdStr)),
-        mDeviceActive(false), mApi1CameraId(api1CameraId)
+        mDeviceActive(false)
 {
     ALOGI("Camera %s: Opened. Client: %s (PID %d, UID %d)", cameraId.string(),
             String8(clientPackageName).string(), clientPid, clientUid);
@@ -336,7 +335,7 @@ void Camera2ClientBase<TClientBase>::notifyRepeatingRequestError(long lastFrameN
 
 template <typename TClientBase>
 int Camera2ClientBase<TClientBase>::getCameraId() const {
-    return mApi1CameraId;
+    return std::stoi(TClientBase::mCameraIdStr.string());
 }
 
 template <typename TClientBase>
diff --git a/services/camera/libcameraservice/common/Camera2ClientBase.h b/services/camera/libcameraservice/common/Camera2ClientBase.h
index e74fbdf..4da422a 100644
--- a/services/camera/libcameraservice/common/Camera2ClientBase.h
+++ b/services/camera/libcameraservice/common/Camera2ClientBase.h
@@ -49,7 +49,6 @@ public:
                       const sp<TCamCallbacks>& remoteCallback,
                       const String16& clientPackageName,
                       const String8& cameraId,
-                      int api1CameraId,
                       int cameraFacing,
                       int clientPid,
                       uid_t clientUid,
@@ -141,8 +140,6 @@ protected:
 
     bool                  mDeviceActive;
 
-    const int             mApi1CameraId; // -1 if client is API2
-
 private:
     template<typename TProviderPtr>
     status_t              initializeImpl(TProviderPtr providerPtr, const String8& monitorTags);
diff --git a/services/camera/libcameraservice/common/CameraProviderManager.cpp b/services/camera/libcameraservice/common/CameraProviderManager.cpp
index b28c1da..73735aa 100644
--- a/services/camera/libcameraservice/common/CameraProviderManager.cpp
+++ b/services/camera/libcameraservice/common/CameraProviderManager.cpp
@@ -20,13 +20,11 @@
 
 #include "CameraProviderManager.h"
 
-#include <algorithm>
 #include <chrono>
 #include <inttypes.h>
 #include <hidl/ServiceManagement.h>
 #include <functional>
 #include <camera_metadata_hidden.h>
-#include <android-base/parseint.h>
 
 namespace android {
 
@@ -40,7 +38,7 @@ const std::string kLegacyProviderName("legacy/0");
 const std::string kExternalProviderName("external/0");
 
 // Slash-separated list of provider types to consider for use via the old camera API
-const std::string kStandardProviderTypes("internal/legacy/external");
+const std::string kStandardProviderTypes("internal/legacy");
 
 } // anonymous namespace
 
@@ -81,7 +79,18 @@ int CameraProviderManager::getCameraCount() const {
     std::lock_guard<std::mutex> lock(mInterfaceMutex);
     int count = 0;
     for (auto& provider : mProviders) {
-        count += provider->mUniqueCameraIds.size();
+        count += provider->mUniqueDeviceCount;
+    }
+    return count;
+}
+
+int CameraProviderManager::getAPI1CompatibleCameraCount() const {
+    std::lock_guard<std::mutex> lock(mInterfaceMutex);
+    int count = 0;
+    for (auto& provider : mProviders) {
+        if (kStandardProviderTypes.find(provider->getType()) != std::string::npos) {
+            count += provider->mUniqueAPI1CompatibleCameraIds.size();
+        }
     }
     return count;
 }
@@ -107,24 +116,6 @@ std::vector<std::string> CameraProviderManager::getAPI1CompatibleCameraDeviceIds
             }
         }
     }
-
-    std::sort(deviceIds.begin(), deviceIds.end(),
-            [](const std::string& a, const std::string& b) -> bool {
-                uint32_t aUint = 0, bUint = 0;
-                bool aIsUint = base::ParseUint(a, &aUint);
-                bool bIsUint = base::ParseUint(b, &bUint);
-
-                // Uint device IDs first
-                if (aIsUint && bIsUint) {
-                    return aUint < bUint;
-                } else if (aIsUint) {
-                    return true;
-                } else if (bIsUint) {
-                    return false;
-                }
-                // Simple string compare if both id are not uint
-                return a < b;
-            });
     return deviceIds;
 }
 
@@ -489,8 +480,6 @@ status_t CameraProviderManager::ProviderInfo::initialize() {
     }
     ALOGI("Connecting to new camera provider: %s, isRemote? %d",
             mProviderName.c_str(), mInterface->isRemote());
-    // cameraDeviceStatusChange callbacks may be called (and causing new devices added)
-    // before setCallback returns
     hardware::Return<Status> status = mInterface->setCallback(this);
     if (!status.isOk()) {
         ALOGE("%s: Transaction error setting up callbacks with camera provider '%s': %s",
@@ -547,10 +536,17 @@ status_t CameraProviderManager::ProviderInfo::initialize() {
         }
     }
 
+    for (auto& device : mDevices) {
+        mUniqueCameraIds.insert(device->mId);
+        if (device->isAPI1Compatible()) {
+            mUniqueAPI1CompatibleCameraIds.insert(device->mId);
+        }
+    }
+    mUniqueDeviceCount = mUniqueCameraIds.size();
+
     ALOGI("Camera provider %s ready with %zu camera devices",
             mProviderName.c_str(), mDevices.size());
 
-    mInitialized = true;
     return OK;
 }
 
@@ -598,15 +594,9 @@ status_t CameraProviderManager::ProviderInfo::addDevice(const std::string& name,
     }
     if (deviceInfo == nullptr) return BAD_VALUE;
     deviceInfo->mStatus = initialStatus;
-    bool isAPI1Compatible = deviceInfo->isAPI1Compatible();
 
     mDevices.push_back(std::move(deviceInfo));
 
-    mUniqueCameraIds.insert(id);
-    if (isAPI1Compatible) {
-        mUniqueAPI1CompatibleCameraIds.insert(id);
-    }
-
     if (parsedId != nullptr) {
         *parsedId = id;
     }
@@ -616,10 +606,6 @@ status_t CameraProviderManager::ProviderInfo::addDevice(const std::string& name,
 void CameraProviderManager::ProviderInfo::removeDevice(std::string id) {
     for (auto it = mDevices.begin(); it != mDevices.end(); it++) {
         if ((*it)->mId == id) {
-            mUniqueCameraIds.erase(id);
-            if ((*it)->isAPI1Compatible()) {
-                mUniqueAPI1CompatibleCameraIds.erase(id);
-            }
             mDevices.erase(it);
             break;
         }
@@ -685,7 +671,6 @@ hardware::Return<void> CameraProviderManager::ProviderInfo::cameraDeviceStatusCh
         CameraDeviceStatus newStatus) {
     sp<StatusListener> listener;
     std::string id;
-    bool initialized = false;
     {
         std::lock_guard<std::mutex> lock(mLock);
         bool known = false;
@@ -712,13 +697,9 @@ hardware::Return<void> CameraProviderManager::ProviderInfo::cameraDeviceStatusCh
             removeDevice(id);
         }
         listener = mManager->getStatusListener();
-        initialized = mInitialized;
     }
     // Call without lock held to allow reentrancy into provider manager
-    // Don't send the callback if providerInfo hasn't been initialized.
-    // CameraService will initialize device status after provider is
-    // initialized
-    if (listener != nullptr && initialized) {
+    if (listener != nullptr) {
         listener->onDeviceStatusChanged(String8(id.c_str()), newStatus);
     }
     return hardware::Void();
diff --git a/services/camera/libcameraservice/common/CameraProviderManager.h b/services/camera/libcameraservice/common/CameraProviderManager.h
index bbe6789..d02abb0 100644
--- a/services/camera/libcameraservice/common/CameraProviderManager.h
+++ b/services/camera/libcameraservice/common/CameraProviderManager.h
@@ -18,7 +18,7 @@
 #define ANDROID_SERVERS_CAMERA_CAMERAPROVIDER_H
 
 #include <vector>
-#include <unordered_set>
+#include <set>
 #include <string>
 #include <mutex>
 
@@ -125,14 +125,16 @@ public:
      */
     int getCameraCount() const;
 
-    std::vector<std::string> getCameraDeviceIds() const;
-
     /**
      * Retrieve the number of API1 compatible cameras; these are internal and
      * backwards-compatible. This is the set of cameras that will be
-     * accessible via the old camera API.
-     * The return value may change dynamically due to external camera hotplug.
+     * accessible via the old camera API, with IDs in range of
+     * [0, getAPI1CompatibleCameraCount()-1]. This value is not expected to change dynamically.
      */
+    int getAPI1CompatibleCameraCount() const;
+
+    std::vector<std::string> getCameraDeviceIds() const;
+
     std::vector<std::string> getAPI1CompatibleCameraDeviceIds() const;
 
     /**
@@ -312,9 +314,9 @@ private:
             static status_t setTorchMode(InterfaceT& interface, bool enabled);
         };
         std::vector<std::unique_ptr<DeviceInfo>> mDevices;
-        std::unordered_set<std::string> mUniqueCameraIds;
+        std::set<std::string> mUniqueCameraIds;
         int mUniqueDeviceCount;
-        std::unordered_set<std::string> mUniqueAPI1CompatibleCameraIds;
+        std::set<std::string> mUniqueAPI1CompatibleCameraIds;
 
         // HALv1-specific camera fields, including the actual device interface
         struct DeviceInfo1 : public DeviceInfo {
@@ -364,8 +366,6 @@ private:
 
         CameraProviderManager *mManager;
 
-        bool mInitialized = false;
-
         // Templated method to instantiate the right kind of DeviceInfo and call the
         // right CameraProvider getCameraDeviceInterface_* method.
         template<class DeviceInfoT>
-- 
2.7.4

